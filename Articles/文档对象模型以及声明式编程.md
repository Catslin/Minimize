文档对象模型以及声明式编程

![image-20231027205759483](C:\Users\npc\AppData\Roaming\Typora\typora-user-images\image-20231027205759483.png)

html 的 dom 树结构

![image-20231027210218180](C:\Users\npc\AppData\Roaming\Typora\typora-user-images\image-20231027210218180.png)

> 在将文档翻译成 DOM 树并进行渲染时，需要将标签闭合是因为 HTML 是一种标记语言，它要求标签必须正确闭合。在解析 HTML 时，浏览器会按照标签的层次结构来构建 DOM 树，所以必须确保标签的正确闭合，以保证 DOM 树的结构正确。
>
> 即使是从上往下渲染，也需要将标签闭合。这是因为浏览器在解析 HTML 时，会按照顺序逐个解析标签，并将它们添加到 DOM 树中。如果标签没有正确闭合，浏览器可能会出现解析错误，导致渲染结果不符合预期。
>
> 另外，将标签正确闭合也有助于代码的可读性和维护性。通过明确地将标签闭合，可以更清晰地表达 HTML 结构，使代码更易于理解和调试。
>
> 总而言之，无论是从上往下渲染还是其他方式，将标签正确闭合是 HTML 规范的要求，也是保证正确解析和渲染的必要条件。

 



```
"
<main id="app">
    <ul id="list">
        <li>Item 1</li>
        <li>Item 1</li>
    </ul>
</mai>
"
```

```
const listElement = document.getElementById("list");

const newListItem = document.createElement("li");

newLisyItem.textContent = "Item 3";

setTimeOut(() => listElement.appendChild(newListItem),1000)
```

------

 

```
<article>
    <h2>Counter</h2>
    <p>You clicked <em id="count">1</em></p>
    <button onclick="setCount()"></button>
</article>
```

```
const counrElement = document.getElementById("count")

function setCount() {
	let count = Number(countElement.textContent)
	count = count +1;
	countElement.textContent = count;
}
```

::

```
<body>
    You clicked <p id="root">0</p>
    <button onclick="addCount()">ADD</button>
</body>
<script>
    const countApp = {
        getCount: () => {
            const countElement = document.getElementById("root")
            return Number(countElement.textContent)
        },
        setCount: (val) => {
            const countElement = document.getElementById("root")
            countElement.textContent = val
        }
    }
    function addCount() {
        let count = countApp.getCount()
        if (count >= 5) {
            countApp.setCount(0)
        } else {
            countApp.setCount(count+1)
        }
    }
</script>
```

:: 函数递归的使用

>虚拟 dom
>
>let markup =
>
>type: 'article',
>
>children: [ 
>
>{
>
>​	type: 'button',
>
>​	  children: [
>
>​	    {
>
>​	        type: 'text',
>
>​            valut: 'click me'
>
>​         }
>
>​       ]
>
>}]
>
>------
>
>const main= document.getElementById("app")
>
>其实就类似于 <button>click me</button>
>
>如果你打印 你会发现这个 main 远比上面的虚拟dom要大得多

> ```js
>  function addElements(pojoElement,parentDOMNode) {
>      let newDOMNode = pojoElement.type === 'text' ? document.createTextNode (pojoElement.value) :documeny.createElement(pojoElement.type);
>      
>      if (pojoElement.children) {
>          pojoElement.children.forEach((child) => {
>              addElements(child,newDOMNode)
>          })
>      }
>      console.log(parentDOMNode)
>      parentDOMNode.appendChild(newDOMNode)
>  }
> 
> addElements(markup,main)
> ```
>
> ![image-20231029104741074](C:\Users\npc\AppData\Roaming\Typora\typora-user-images\image-20231029104741074.png)

![image-20231029111439824](C:\Users\npc\AppData\Roaming\Typora\typora-user-images\image-20231029111439824.png)
