<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Build own reactJS</title>
    <link rel="stylesheet" href="../../../css/page.css">
    <link rel="stylesheet" href="../../../css/bun.css">
</head>

<body>
    <div class="contentsTag">
        <a href="../../../../index.html">#HOME</a>
        <h2>you need before entering react?</h2>
        <h4><a href="#what">Part1 :: what is the arrow function.</a></h4>
        <h4><a href="#ternary">Part2 :: But if you use the ternary operator.</a></h4>
        <h4><a href="#objects">Part3 :: Deconstruct key-value pairs in objects.</a></h4>
        <h4><a href="#commonly">Part4 :: Three commonly used operations on js data.</a></h4>
    </div>
    <div class="context">
        <p>
        <h2 id="what">what is the arrow function</h2>

        <pre>
                function doSomething {}
                    like as
                const doSomething = () => {}</pre>

        It will be better when you use callback function, if it is the first
        <pre>export default function doSomething() {}</pre>
        The second type
        <pre>export const doSomething = () => {}</pre>

        In react we often use this::
        <pre>
                const MyComponent = () => {
                    return <div></div>
                }
            </pre>
        We can also use arrow functions to create anonymous functions::
        For example, in button
        <pre>[button onClick = {() => {console.log("hello word")}}</button></pre>
        In this way, the function will also be executed and does not need to be declared


        <h2 id="ternary">But if you use the ternary operator</h2>
        "I want to eat an apple but if there are no apples, I will eat a banana."
        <pre>const iEat = apple || banana;</pre>
        (is like const iEat = have ? apple : banana; have is a Boolean value judgment)

        So you can use it in combination like this
        <pre>
                const iEat = () => {
                    "return have ? `div apple /div : div banna /div;"
                }
            </pre>
        This will return you your food element


        <h2 id="objects">Deconstruct key-value pairs in objects</h2>
        <pre>
                const person = {
                    name: "catslin",
                    age: 21,
                    isMarried: false,
                };
            </pre>
        so we should
        <pre>
            const name = person.name: ???
            const {newName,newAgr,newIsMarried} = person
        </pre>
        This can directly destructure the key-value pairs in the object
        Or we can also set the properties of the object like this
        <pre>
            const name = "Catslin"
                ...
            const person = {
                name,
                ...
            }
        </pre>
        This will automatically assign a value to the name attribute with the same name, we do not need to use name=name
        When we want to copy this user's template but modify the name attribute inside
        <pre>const person2 = {...person,name: "sama"} >> ...person</pre>
        This means that all content is retained in the person object, and we can modify it directly in this scope
        We'll add properties to it like this
        <pre>
            const fruits = ["apple","banna"]
            const fruits2 = [...fruit,"carrot"]
        </pre>
        Do you like to eat carrots? Now it is also a fruit



        <h2 id="commonly">Three commonly used operations on js data: .map(), .filter(), reduce()</h2>
        Use .map() to manipulate elements in your data
        <pre>
            const fruits = ["apple","banna"]

            fruits.map((fruit) => {
                //All fruits will be traversed here
                //If we return "apple" >> ["apple","apple"] then all elements will be replaced
                return name+" is fruit" > ["apple is fruit","banna is fruit"] //Return new element
            })
        </pre>
        >> filter is like a .map() with added judgment conditions

        <pre>
            fruits.filter((fruit) => {
                return fruit !== "apple" //This will remove all apples
            })
        </pre>
        <span> [The map method will iterate through each element in the array and create a new array based on the return
            value of the callback function. In the callback function, you can operate or transform each element and
            return a new value. Ultimately, the map method returns a new array with the same length as the original
            array. ["apple is
            fruit", "banana is fruit"].]</span>
        <span> [The filter method will traverse each element in the array and determine whether to retain the element
            based on the return value of the callback function. In the callback function, if the return value is true,
            the element is retained; if the return value is false, the element is filtered. Finally, filter
            The method will return a new array containing only elements that meet the conditions. If the element is not
            equal to "apple", the element is retained; if the element is equal to "apple", the element is filtered.
            Finally returns a new array ["banana"]]
        </span>
        <br>
        <span> The reduce method accepts a callback function as a parameter and can accept two optional parameters:
            initial value and context object. The callback function accepts four parameters: accumulator, current value,
            current index
            index) and the original array (array). </span>

        The callback function is called on each element of the array, and the accumulator value is updated with the
        return value of the callback function. During each iteration, the accumulator can be operated on to finally
        obtain a reduced value.

        Here is an example using the reduce method:

        <pre>
                const numbers = [1, 2, 3, 4, 5];

                const sum = numbers.reduce((accumulator, currentValue) => {
                    return accumulator + currentValue;
                }, 0);
       
                console.log(sum); // Output: 15
                const numbers = [1, 2, 3, 4, 5];
       
                const sum = numbers.reduce((accumulator, currentValue) => {
                    return accumulator + currentValue;
                }, 0);
       
                console.log(sum); // Output: 15
            </pre>
        In the above example, the initial value of accumulator is 0, on the first iteration, the value of accumulator is
        0 and the value of currentValue is 1. The callback function adds them and returns the result 1. Then, on the
        next iteration, the accumulator
        has a value of 1 and currentValue has a value of 2, the callback function adds them and returns the result 3.
        And so on, until the entire array is traversed, and the final value of the accumulator is 15</p>
    </div>
</body>

</html>